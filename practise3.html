<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced SVG Drawing Tool</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px;
            background-color: #f0f0f0;
        }

        h1 {
            color: #333;
        }

        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
        }

        .controls button {
            padding: 8px 16px;
            font-size: 16px;
            cursor: pointer;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #e9e9e9;
        }
        
        .controls button.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }

        #drawingCanvas {
            border: 2px solid #333;
            background-color: #fff;
            width: 800px;
            height: 600px;
        }
    </style>
</head>
<body>
    <h1>Advanced SVG Drawing Tool</h1>
    
    <div class="controls">
        <button id="lineBtn" class="active" onclick="setDrawingMode('line')">Line</button>
        <button id="rectBtn" onclick="setDrawingMode('rectangle')">Rectangle</button>
        <button id="circleBtn" onclick="setDrawingMode('circle')">Circle</button>
    </div>

    <svg id="drawingCanvas"></svg>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        let isDrawing = false;
        let startX, startY;
        let currentShape = null;
        let drawingMode = 'line';

        // Switch drawing mode
        function setDrawingMode(mode) {
            drawingMode = mode;
            document.querySelectorAll('.controls button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`${mode}Btn`).classList.add('active');
        }

        // Mouse position relative to SVG
        function getMousePosition(event) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        }

        // Start drawing
        canvas.addEventListener('mousedown', (event) => {
            isDrawing = true;
            const { x, y } = getMousePosition(event);
            startX = x;
            startY = y;

            if (drawingMode === 'line') {
                currentShape = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                currentShape.setAttribute('x1', startX);
                currentShape.setAttribute('y1', startY);
                currentShape.setAttribute('x2', startX);
                currentShape.setAttribute('y2', startY);
                currentShape.setAttribute('stroke', 'red');
                currentShape.setAttribute('stroke-width', '2');
                currentShape.setAttribute('stroke-linecap', 'round');
            } else if (drawingMode === 'rectangle') {
                currentShape = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                currentShape.setAttribute('x', startX);
                currentShape.setAttribute('y', startY);
                currentShape.setAttribute('width', '0');
                currentShape.setAttribute('height', '0');
                currentShape.setAttribute('stroke', 'blue');
                currentShape.setAttribute('stroke-width', '2');
                currentShape.setAttribute('fill', 'transparent');
            } else if (drawingMode === 'circle') {
                currentShape = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                currentShape.setAttribute('cx', startX);
                currentShape.setAttribute('cy', startY);
                currentShape.setAttribute('r', '0');
                currentShape.setAttribute('stroke', 'green');
                currentShape.setAttribute('stroke-width', '2');
                currentShape.setAttribute('fill', 'transparent');
            }

            if (currentShape) {
                canvas.appendChild(currentShape);
            }
        });

        // Update shape while dragging
        canvas.addEventListener('mousemove', (event) => {
            if (!isDrawing || !currentShape) return;

            const { x, y } = getMousePosition(event);

            if (drawingMode === 'line') {
                currentShape.setAttribute('x2', x);
                currentShape.setAttribute('y2', y);
            } else if (drawingMode === 'rectangle') {
                const newX = Math.min(startX, x);
                const newY = Math.min(startY, y);
                const width = Math.abs(x - startX);
                const height = Math.abs(y - startY);
                currentShape.setAttribute('x', newX);
                currentShape.setAttribute('y', newY);
                currentShape.setAttribute('width', width);
                currentShape.setAttribute('height', height);
            } else if (drawingMode === 'circle') {
                const radius = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));
                currentShape.setAttribute('r', radius);
            }
        });

        // Finish drawing
        canvas.addEventListener('mouseup', () => {
            if (!isDrawing || !currentShape) return;

            // âš¡ Removed the stroke-dasharray animation so line never disappears
            isDrawing = false;
            currentShape = null;
        });

        // Reset if leaving canvas
        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
            currentShape = null;
        });
    </script>
</body>
</html>